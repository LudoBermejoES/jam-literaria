# Database Documentation

## Overview

Jam Literaria uses **SQLite** as an embedded relational database with ACID compliance. The database is stored as a single file and accessed through Node.js using the `sqlite` package.

**Schema Location**: [database/schema.sql](../database/schema.sql)
**Database File**: `database/jam_literaria.db`
**Models Location**: [server/models/](../server/models/)

## Database Schema

### Tables Overview

```
users (1) ──────┐
                 │
                 ├──── sessions (1)
                 │         │
session_participants (N:M)  │
                           │
                     ┌─────┴─────┬─────────────┐
                     │           │             │
                  ideas (N)   votes (N)   session_metadata (1)
```

### 1. users

**Purpose**: Store user accounts and activity tracking

**Schema**:
```sql
CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  last_active TEXT DEFAULT CURRENT_TIMESTAMP
) STRICT;
```

**Fields**:
- `id` (TEXT): UUID v4 generated by application
- `name` (TEXT): User's display name (not unique, allows duplicates)
- `created_at` (TEXT): ISO timestamp of account creation
- `last_active` (TEXT): ISO timestamp of last activity

**Indexes**: Primary key on `id`

**Notes**:
- No authentication (username/password) - simple name-based access
- Names can be duplicated (John, John, John are different users)
- UUIDs prevent collisions even with same names

**Model**: [server/models/User.js](../server/models/User.js)

**Common Queries**:
```sql
-- Get user by ID
SELECT * FROM users WHERE id = ?;

-- Update last active timestamp
UPDATE users SET last_active = CURRENT_TIMESTAMP WHERE id = ?;

-- Get all users (admin only)
SELECT * FROM users ORDER BY created_at DESC;
```

---

### 2. sessions

**Purpose**: Store session lifecycle and state

**Schema**:
```sql
CREATE TABLE IF NOT EXISTS sessions (
  id TEXT PRIMARY KEY,
  code TEXT UNIQUE NOT NULL,
  status TEXT DEFAULT 'WAITING',
  current_round INTEGER DEFAULT 0,
  owner_id TEXT NOT NULL,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (owner_id) REFERENCES users(id)
) STRICT;
```

**Fields**:
- `id` (TEXT): UUID v4 session identifier
- `code` (TEXT): 6-character alphanumeric session code (e.g., "ABC123")
- `status` (TEXT): Current session status (enum-like)
  - `WAITING`: Participants joining, not started
  - `SUBMITTING_IDEAS`: Idea submission phase
  - `VOTING`: Voting phase (may span multiple rounds)
  - `COMPLETED`: Final results available
- `current_round` (INTEGER): Current voting round (0 = first round)
- `owner_id` (TEXT): Foreign key to user who created session
- `created_at` (TEXT): Session creation timestamp
- `updated_at` (TEXT): Last update timestamp

**Indexes**:
- Primary key on `id`
- Unique constraint on `code`
- Foreign key on `owner_id` → `users(id)`

**Notes**:
- Session codes are generated with characters excluding confusing ones (0, O, I, 1)
- Codes are case-insensitive when joining (normalized to uppercase)
- `current_round` increments for each tiebreaker voting round
- Status changes are linear: WAITING → SUBMITTING_IDEAS → VOTING → COMPLETED

**Model**: [server/models/Session.js](../server/models/Session.js)

**Common Queries**:
```sql
-- Get session by ID with owner info
SELECT s.*, u.name as owner_name,
  (SELECT COUNT(*) FROM session_participants WHERE session_id = s.id) as participant_count
FROM sessions s
JOIN users u ON s.owner_id = u.id
WHERE s.id = ?;

-- Get session by code
SELECT * FROM sessions WHERE code = ?;

-- Update session status
UPDATE sessions
SET status = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?;

-- Update current round
UPDATE sessions
SET current_round = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?;
```

---

### 3. session_participants

**Purpose**: Many-to-many relationship between users and sessions

**Schema**:
```sql
CREATE TABLE IF NOT EXISTS session_participants (
  session_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  PRIMARY KEY (session_id, user_id),
  FOREIGN KEY (session_id) REFERENCES sessions(id),
  FOREIGN KEY (user_id) REFERENCES users(id)
) STRICT;
```

**Fields**:
- `session_id` (TEXT): Foreign key to sessions
- `user_id` (TEXT): Foreign key to users

**Indexes**:
- Composite primary key on `(session_id, user_id)`
- Foreign keys prevent orphaned records

**Notes**:
- Owner is automatically added as participant when creating session
- Composite key prevents duplicate participant entries
- No timestamp (when user joined) - could be added for analytics

**Common Queries**:
```sql
-- Get all participants in a session
SELECT u.*
FROM users u
JOIN session_participants sp ON u.id = sp.user_id
WHERE sp.session_id = ?
ORDER BY u.name ASC;

-- Get all sessions for a user
SELECT s.*, u.name as owner_name
FROM sessions s
JOIN users u ON s.owner_id = u.id
JOIN session_participants sp ON s.id = sp.session_id
WHERE sp.user_id = ?
ORDER BY s.created_at DESC;

-- Add participant to session
INSERT INTO session_participants (session_id, user_id)
VALUES (?, ?);

-- Check if user is participant
SELECT COUNT(*) as count
FROM session_participants
WHERE session_id = ? AND user_id = ?;
```

---

### 4. ideas

**Purpose**: Store submitted ideas with attribution

**Schema**:
```sql
CREATE TABLE IF NOT EXISTS ideas (
  id TEXT PRIMARY KEY,
  content TEXT NOT NULL,
  author_id TEXT NOT NULL,
  session_id TEXT NOT NULL,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (author_id) REFERENCES users(id),
  FOREIGN KEY (session_id) REFERENCES sessions(id)
) STRICT;
```

**Fields**:
- `id` (TEXT): UUID v4 idea identifier
- `content` (TEXT): The idea text (unlimited length)
- `author_id` (TEXT): Foreign key to user who submitted
- `session_id` (TEXT): Foreign key to session
- `created_at` (TEXT): Submission timestamp

**Indexes**:
- Primary key on `id`
- Foreign keys on `author_id` and `session_id`
- **Recommended**: Add index on `session_id` for performance

**Notes**:
- No character limit on idea content (frontend could add one)
- Author is stored but not displayed to voters (anonymous voting)
- Session owner can see authors for moderation
- Ideas cannot be edited after submission

**Model**: [server/models/Idea.js](../server/models/Idea.js)

**Common Queries**:
```sql
-- Get all ideas for a session
SELECT i.*, u.name as author_name
FROM ideas i
JOIN users u ON i.author_id = u.id
WHERE i.session_id = ?
ORDER BY i.created_at ASC;

-- Get ideas by specific IDs
SELECT i.*, u.name as author_name
FROM ideas i
JOIN users u ON i.author_id = u.id
WHERE i.id IN (?, ?, ?)
ORDER BY i.created_at ASC;

-- Count ideas per user in session
SELECT author_id, COUNT(*) as count
FROM ideas
WHERE session_id = ?
GROUP BY author_id;

-- Get user's ideas in session
SELECT * FROM ideas
WHERE session_id = ? AND author_id = ?;
```

---

### 5. votes

**Purpose**: Track votes across multiple rounds

**Schema**:
```sql
CREATE TABLE IF NOT EXISTS votes (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  idea_id TEXT NOT NULL,
  session_id TEXT NOT NULL,
  round INTEGER NOT NULL,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  UNIQUE (user_id, idea_id, round, session_id),
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (idea_id) REFERENCES ideas(id),
  FOREIGN KEY (session_id) REFERENCES sessions(id)
) STRICT;
```

**Fields**:
- `id` (TEXT): UUID v4 vote identifier
- `user_id` (TEXT): Who voted
- `idea_id` (TEXT): What they voted for
- `session_id` (TEXT): Which session
- `round` (INTEGER): Which voting round (0, 1, 2, ...)
- `created_at` (TEXT): When they voted

**Indexes**:
- Primary key on `id`
- **Unique constraint** on `(user_id, idea_id, round, session_id)`
- Foreign keys on all reference fields
- **Recommended**: Add index on `(session_id, round)` for performance

**Unique Constraint Explanation**:
- Prevents duplicate votes in same round
- Allows voting for same idea in different rounds
- Ensures one vote per user-idea-round combination

**Notes**:
- Multiple rounds supported (tiebreaker scenarios)
- Vote history preserved (previous rounds not deleted)
- No vote modification/deletion (audit trail)
- `round` matches `sessions.current_round` when vote was cast

**Model**: [server/models/Vote.js](../server/models/Vote.js)

**Common Queries**:
```sql
-- Get vote counts for a round
SELECT
  i.id as idea_id,
  i.content,
  i.author_id,
  u.name as author_name,
  COUNT(v.id) as vote_count
FROM ideas i
LEFT JOIN votes v ON i.id = v.idea_id AND v.round = ? AND v.session_id = ?
LEFT JOIN users u ON i.author_id = u.id
WHERE i.session_id = ?
GROUP BY i.id
ORDER BY vote_count DESC;

-- Check if user voted in round
SELECT COUNT(*) > 0 as has_voted
FROM votes
WHERE user_id = ? AND session_id = ? AND round = ?;

-- Get user's votes in a round
SELECT v.*, i.content as idea_content
FROM votes v
JOIN ideas i ON v.idea_id = i.id
WHERE v.user_id = ? AND v.session_id = ? AND v.round = ?;

-- Count participants who voted
SELECT COUNT(DISTINCT user_id) as voted_count
FROM votes
WHERE session_id = ? AND round = ?;
```

---

### 6. session_metadata

**Purpose**: Store additional session state as JSON

**Schema**:
```sql
CREATE TABLE IF NOT EXISTS session_metadata (
  session_id TEXT PRIMARY KEY,
  ideas_elegidas TEXT,        -- JSON array of idea IDs
  ideas_candidatas TEXT,      -- JSON array of idea IDs
  mensaje_ronda TEXT,
  mensaje_final TEXT,
  required_votes INTEGER,     -- Votes required for current round
  FOREIGN KEY (session_id) REFERENCES sessions(id)
) STRICT;
```

**Fields**:
- `session_id` (TEXT): One-to-one with sessions table
- `ideas_elegidas` (TEXT): JSON array of selected winner IDs (accumulated)
  - Example: `["uuid-1", "uuid-2"]`
- `ideas_candidatas` (TEXT): JSON array of candidate IDs for current round
  - Example: `["uuid-3", "uuid-4", "uuid-5"]`
- `mensaje_ronda` (TEXT): Message for current voting round
  - Example: `"Ronda 2 de votación para desempate"`
- `mensaje_final` (TEXT): Final message when completed
  - Example: `"Las ideas ganadoras han sido seleccionadas"`
- `required_votes` (INTEGER): Number of votes each participant must cast
  - Example: `3` (normal), `2` (3 candidates), `1` (2 candidates)

**Indexes**:
- Primary key on `session_id` (one-to-one with sessions)
- Foreign key ensures session exists

**Notes**:
- Created automatically when session is created
- JSON fields are TEXT in SQLite, parsed by application
- Metadata is updated after each voting round
- **Important**: `ideas_elegidas` accumulates across rounds
- `ideas_candidatas` changes each round (only tied ideas)

**Model**: Managed by [Session.js](../server/models/Session.js) methods

**Common Queries**:
```sql
-- Get session metadata
SELECT * FROM session_metadata WHERE session_id = ?;

-- Update metadata (partial update)
UPDATE session_metadata
SET
  ideas_elegidas = COALESCE(?, ideas_elegidas),
  ideas_candidatas = COALESCE(?, ideas_candidatas),
  mensaje_ronda = COALESCE(?, mensaje_ronda),
  mensaje_final = COALESCE(?, mensaje_final),
  required_votes = COALESCE(?, required_votes)
WHERE session_id = ?;
```

**Example State Evolution**:

**Round 1 (Initial)**:
```json
{
  "ideas_elegidas": null,
  "ideas_candidatas": null,
  "required_votes": 3
}
```

**After Round 1 (2 winners, 3 tied)**:
```json
{
  "ideas_elegidas": ["id-A", "id-B"],
  "ideas_candidatas": ["id-C", "id-D", "id-E"],
  "mensaje_ronda": "Ronda 2 de votación para desempate",
  "required_votes": 1
}
```

**After Round 2 (Complete)**:
```json
{
  "ideas_elegidas": ["id-A", "id-B", "id-C"],
  "ideas_candidatas": null,
  "mensaje_final": "Las ideas ganadoras han sido seleccionadas",
  "required_votes": null
}
```

---

## Database Models (ORM Layer)

### Active Record Pattern

All models use the **Active Record** pattern with static methods:

```javascript
class ModelName {
  static create(data) { /* ... */ }
  static getById(id) { /* ... */ }
  static update(id, data) { /* ... */ }
  static delete(id) { /* ... */ }
}
```

### 1. User Model

**File**: [server/models/User.js](../server/models/User.js)

**Methods**:
```javascript
User.createUser(name)
User.getUserById(id)
User.getUserByName(name)
User.getAllUsers()
User.updateUserLastActive(id)
User.deleteUser(id)
```

**Example Usage**:
```javascript
const user = User.createUser('John Doe');
// Returns: { id: 'uuid...', name: 'John Doe', created_at: '...', ... }

const found = User.getUserById(user.id);
User.updateUserLastActive(user.id);
```

---

### 2. Session Model

**File**: [server/models/Session.js](../server/models/Session.js)

**Constants**:
```javascript
export const SESSION_STATUS = {
  WAITING: 'WAITING',
  SUBMITTING_IDEAS: 'SUBMITTING_IDEAS',
  VOTING: 'VOTING',
  COMPLETED: 'COMPLETED'
};
```

**Methods**:
```javascript
Session.createSession(ownerId)
Session.getSessionById(id)
Session.getSessionByCode(code)
Session.getAllSessions()
Session.getSessionsByParticipant(userId)
Session.updateSessionStatus(id, status)
Session.updateSessionRound(id, round)
Session.addParticipant(sessionId, userId)
Session.getParticipants(sessionId)
Session.updateSessionMetadata(sessionId, metadata)
Session.getSessionMetadata(sessionId)
Session.deleteSession(id)
Session.generateSessionCode()
```

**Special Logic**:

**Session Code Generation**:
```javascript
static generateSessionCode() {
  const characters = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  // Excludes: O, I, 0, 1 (confusing characters)
  let code = '';
  for (let i = 0; i < 6; i++) {
    code += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  // Recursively regenerate if collision detected
  if (codeExists(code)) return this.generateSessionCode();
  return code;
}
```

**Example Usage**:
```javascript
const session = Session.createSession(userId);
// Returns: { id: 'uuid...', code: 'ABC123', status: 'WAITING', ... }

Session.addParticipant(session.id, anotherUserId);
Session.updateSessionStatus(session.id, SESSION_STATUS.VOTING);
```

---

### 3. Idea Model

**File**: [server/models/Idea.js](../server/models/Idea.js)

**Methods**:
```javascript
Idea.createIdea(content, authorId, sessionId)
Idea.getIdeaById(id)
Idea.getIdeasBySessionId(sessionId)
Idea.getIdeasByAuthor(authorId, sessionId)
Idea.getIdeasByIds(ideaIds)
Idea.deleteIdea(id)
Idea.countIdeasByAuthor(authorId, sessionId)
```

**Example Usage**:
```javascript
const idea = Idea.createIdea(
  'Build a real-time voting system',
  userId,
  sessionId
);

const allIdeas = Idea.getIdeasBySessionId(sessionId);
const count = Idea.countIdeasByAuthor(userId, sessionId);
```

---

### 4. Vote Model

**File**: [server/models/Vote.js](../server/models/Vote.js)

**Methods**:
```javascript
Vote.createVote(userId, ideaId, sessionId, round)
Vote.getVotesBySessionAndRound(sessionId, round)
Vote.getVoteCountsByIdea(sessionId, round)
Vote.hasUserVotedInRound(userId, sessionId, round)
Vote.getVotesByUserSessionAndRound(userId, sessionId, round)
Vote.countVotedParticipants(sessionId, round)
Vote.deleteVotesForSession(sessionId)
```

**Critical Method** (Duplicate Prevention):
```javascript
static hasUserVotedInRound(userId, sessionId, round) {
  const db = getDatabase();
  const stmt = db.prepare(`
    SELECT COUNT(*) as count
    FROM votes
    WHERE user_id = ? AND session_id = ? AND round = ?
  `);
  const result = stmt.get(userId, sessionId, round);
  return result && result.count > 0;
}
```

**Vote Count Query** (Complex JOIN):
```javascript
static getVoteCountsByIdea(sessionId, round) {
  const db = getDatabase();
  const stmt = db.prepare(`
    SELECT
      i.id as idea_id,
      i.content,
      i.author_id,
      u.name as author_name,
      COUNT(v.id) as vote_count
    FROM ideas i
    LEFT JOIN votes v ON i.id = v.idea_id AND v.round = ? AND v.session_id = ?
    LEFT JOIN users u ON i.author_id = u.id
    WHERE i.session_id = ?
    GROUP BY i.id
    ORDER BY vote_count DESC, i.created_at ASC
  `);
  return stmt.all(round, sessionId, sessionId);
}
```

---

## Database Connection Management

**File**: [server/models/db.js](../server/models/db.js)

**Implementation**:
```javascript
import Database from 'better-sqlite3';

let db = null;

export function initDatabase() {
  const dbPath = process.env.DATABASE_PATH || '../database/jam_literaria.db';
  db = new Database(dbPath, { verbose: console.log });

  // Enable foreign keys (important!)
  db.pragma('foreign_keys = ON');

  console.log('Database initialized');
  return db;
}

export function getDatabase() {
  if (!db) {
    throw new Error('Database not initialized');
  }
  return db;
}

export function closeDatabase() {
  if (db) {
    db.close();
    db = null;
    console.log('Database closed');
  }
}
```

**Important Settings**:
- `foreign_keys = ON`: Enables referential integrity
- Singleton pattern: One connection shared across app
- Synchronous API (better-sqlite3): No async/await needed

---

## Transactions

### Manual Transaction Example

```javascript
const db = getDatabase();

try {
  db.exec('BEGIN TRANSACTION');

  // Delete all related data
  db.prepare('DELETE FROM votes WHERE session_id = ?').run(sessionId);
  db.prepare('DELETE FROM ideas WHERE session_id = ?').run(sessionId);
  db.prepare('DELETE FROM session_participants WHERE session_id = ?').run(sessionId);
  db.prepare('DELETE FROM session_metadata WHERE session_id = ?').run(sessionId);
  db.prepare('DELETE FROM sessions WHERE id = ?').run(sessionId);

  db.exec('COMMIT');
} catch (error) {
  db.exec('ROLLBACK');
  throw error;
}
```

**Used in**: [Session.deleteSession()](../server/models/Session.js:333-388)

---

## Database Migrations

### Current Approach

**No formal migration system** - schema changes done manually:

1. Update [database/schema.sql](../database/schema.sql)
2. Create migration script in [server/scripts/](../server/scripts/)
3. Run migration manually

### Example Migration

**File**: [server/scripts/migrate-add-required-votes.js](../server/scripts/migrate-add-required-votes.js)

```javascript
import { getDatabase, initDatabase, closeDatabase } from '../models/db.js';

initDatabase();
const db = getDatabase();

// Add new column if it doesn't exist
const columns = db.prepare("PRAGMA table_info(session_metadata)").all();
const hasColumn = columns.some(col => col.name === 'required_votes');

if (!hasColumn) {
  db.prepare(`
    ALTER TABLE session_metadata
    ADD COLUMN required_votes INTEGER
  `).run();
  console.log('Added required_votes column');
}

closeDatabase();
```

**Run**: `node server/scripts/migrate-add-required-votes.js`

### Database Reset

**Script**: [server/scripts/reset-db.js](../server/scripts/reset-db.js)

**Purpose**: Drop all tables and recreate from schema (dev only!)

```bash
npm run reset-db
```

---

## Performance Considerations

### Current State

**Good**:
- Prepared statements (SQL injection protection + performance)
- Primary keys on all tables
- Foreign key constraints for data integrity
- STRICT mode prevents type coercion

**Missing**:
- Indexes on foreign keys (SQLite doesn't auto-create)
- Index on `session_id` in ideas table
- Index on `(session_id, round)` in votes table
- Index on `author_id` in ideas table

### Recommended Indexes

```sql
-- Ideas table
CREATE INDEX idx_ideas_session ON ideas(session_id);
CREATE INDEX idx_ideas_author ON ideas(author_id);

-- Votes table
CREATE INDEX idx_votes_session_round ON votes(session_id, round);
CREATE INDEX idx_votes_user_session ON votes(user_id, session_id);

-- Session participants
CREATE INDEX idx_participants_user ON session_participants(user_id);
```

### Query Optimization

**Before** (N+1 queries):
```javascript
const sessions = getAllSessions();
for (const session of sessions) {
  session.participants = getParticipants(session.id);  // N queries
}
```

**After** (1 query with JOIN):
```javascript
const sessions = db.prepare(`
  SELECT s.*,
    GROUP_CONCAT(u.name) as participant_names
  FROM sessions s
  LEFT JOIN session_participants sp ON s.id = sp.session_id
  LEFT JOIN users u ON sp.user_id = u.id
  GROUP BY s.id
`).all();
```

---

## Data Integrity

### Foreign Key Cascades

**Current**: No CASCADE rules defined

**Recommendation**: Add cascades for cleanup

```sql
CREATE TABLE votes (
  -- ...
  FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE,
  FOREIGN KEY (idea_id) REFERENCES ideas(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

**Effect**: Deleting a session auto-deletes all votes, ideas, etc.

### Unique Constraints

1. **sessions.code**: UNIQUE - prevents duplicate session codes
2. **votes(user_id, idea_id, round, session_id)**: UNIQUE - prevents duplicate votes

### Check Constraints

**Not currently used**, but could add:

```sql
CREATE TABLE sessions (
  -- ...
  status TEXT CHECK(status IN ('WAITING', 'SUBMITTING_IDEAS', 'VOTING', 'COMPLETED')),
  current_round INTEGER CHECK(current_round >= 0)
);
```

---

## Backup and Recovery

### Manual Backup

```bash
# Backup database file
cp database/jam_literaria.db database/backup-$(date +%Y%m%d).db

# Restore from backup
cp database/backup-20240101.db database/jam_literaria.db
```

### SQLite Backup API

```javascript
import Database from 'better-sqlite3';

const source = new Database('./database/jam_literaria.db');
const backup = source.backup('./database/backup.db');

backup.step(-1);  // Backup all pages
backup.finish();
```

### Production Recommendations

1. **Daily automated backups**
2. **Off-site backup storage**
3. **Point-in-time recovery** (migrate to PostgreSQL)
4. **Backup verification** (test restore periodically)

---

## Migration to PostgreSQL

### Why Migrate?

**SQLite Limitations**:
- Single-writer concurrency
- No connection pooling
- No replication
- Limited to single server

**PostgreSQL Benefits**:
- Multi-writer concurrency
- Connection pooling
- Streaming replication
- Better full-text search
- JSON column type (vs TEXT)
- More robust for production

### Migration Checklist

1. **Schema conversion**
   - TEXT → VARCHAR, UUID type
   - STRICT mode → NOT NULL constraints
   - JSON columns → JSONB type

2. **Data migration**
   - Export SQLite to SQL dump
   - Transform to PostgreSQL format
   - Import data

3. **Code changes**
   - Replace `better-sqlite3` with `pg` or `knex`
   - Async/await for all queries
   - Connection pooling setup
   - Environment-specific configs

4. **Testing**
   - Full integration test suite
   - Load testing
   - Migration rollback plan

**Estimated effort**: 1-2 weeks for full migration and testing
